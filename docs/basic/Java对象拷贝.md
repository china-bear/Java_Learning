## JAVA引用拷贝
引用拷贝也就是我们常用的对象赋值，这种方式不会生成新的对象，只会在原对象上增加了一个新的对象引用，两个引用指向的对象还是是同一个,
java 对象默认的赋值方式都是引用拷贝

程序中如果像这种在一个对象上多次赋值再并使用其实是很危险的，有时候调用的层次多了被传递的使用者修改了对象属性会造成业务逻辑上的错误
（从ObjCopyTest01例子，如果在user3修改属性值之后，还有业务代码要拿user1来进行业务操作的话，那么此时的user1属性值都已经被修改了，这样势必会产生业务上的错误），而这样的问题又比较难发现，并且这样也会造成代码的理解成本变高，可读性也会变差，所以开发中我们尽量避免对象多层传递赋值。


##对象浅拷贝
如果原型对象的成员变量是值类型，将复制一份给克隆对象，也就是说在堆中拥有独立的空间；如果原型对象的成员变量是引用类型，
则将引用对象的地址复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址。换句话说，在浅克隆中，
当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。
也许你也有个疑问，为什么clone的方式不能把其引用的对象也重新生成一份，那多省事情，我想应该有以下几个原因；

1、不给其他类强加意义

这个就好比，User类为了能进行浅拷贝就实现了Cloneable 接口，但是其引用对象Teacher没有实现Cloneable 也许说明他本身就不想被拷贝，如果在拷贝User的情况下，同时也把Teacher拷贝了，这不就等于干了一件没有遵循他人同意的事，干了之后人家还不知道，傻傻的以为没人可以通过clone来拷贝出另外一个Teacher。

2、不破坏其原来对象的代码逻辑

如果User引用的Teacher 是个单例模式的对象，那如果在User拷贝的时候同时也拷贝出了一个Teacher 那是不是就会破坏Teacher这个单例模式对象的逻辑初衷

##对象深拷贝
### 对象实现 Cloneable 接口方式实现深拷贝


### 对象实现序列化接口实现深拷贝

## 四种主流的对象属性拷贝工具:
PropertyUtils (commons beanutils)
BeanUtils (commons beanutils)
BeanUtils (Spring beans)
BeanCopier (cglib)  #不是深拷贝 


https://juejin.im/post/6844904013196951560
https://zhuanlan.zhihu.com/p/30320149
https://www.jianshu.com/p/7eb7dc464eed