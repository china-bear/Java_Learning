https://blog.csdn.net/qq_42570487/article/details/107171669
https://github.com/leileiyuan/generic/tree/master/generic/src/com/belongtou/generic
https://zhuanlan.zhihu.com/p/28242753
https://zhuanlan.zhihu.com/p/64585072  秒懂Java泛型
西瓜视频  JavaSE 强化泛型 （黑马程序员）  

# 背景
JAVA推出泛型以前，程序员可以构建一个元素类型为Object的集合，该集合能够存储任意的数据类型对象，而在使用该集合的过程中，
需要程序员明确知道存储每个元素的数据类型，否则很容易引发ClassCastException异常


#泛型的概念

Java泛型（generics）是JDK5 中引入的一个新特性，泛型提供了编译时类型安全监测机制，该机制允许我们在编译检测时检测到非法的类型数据结构。
泛型的本质就是参数化类型，也就是所操纵的数据类型被指定为一个参数(数据类型参数化)

#泛型的好处
类型安全
消除了强制类型的转换


#泛型类
##语法
class 类名称 <泛型标识,泛型标识,...> {
	private 泛型标识 变量名;
	...
}

## 使用用法
类名<具体的数据类型> 对象名 = new 类名<具体的数据类型>();

## 在 Java1.7 以后，后面的<>中的具体的数据类型可以省略不写
类名<具体的数据类型> 对象名 = new 类名<>();

##泛型类的注意事项：
泛型类，如果没有指定具体的数据类型，此时，操作的类型是Object
泛型的类型参数只能是类类型，不能是基本数据类型
泛型类型在逻辑上可以看作是多个不同的类型，但实际上都是相同的类型

## 从泛型类派生子类：
子类也是泛型类，子类和父类的泛型类型要一致
class ChildGeneric<T> extends Generic<T>
子类不是泛型类，父类要明确泛型的数据类型,如果父类没指定类型默认就是Object类型
class ChildGeneric extends Generic<String>

#泛型接口
interface 接口名称<泛型标识,泛型标识，...>{
	泛型标识 方法名();
}

##实现类不是泛型类，接口要明确数据类型，如果接口没有指定类型默认就是Object类型
##实现类也是泛型类，实现类和接口的泛型类型要一致

#泛型方法：
 
 ##泛型类，是在实例化类的时候指明泛型的具体类型
 ##泛型方法，是在调用方法的时候指明泛型的具体类型
 语法
 修饰符 <T,E,...> 返回值类型 方法名(形参列表) {
 	方法体...
 }
##public 与返回值中间非常重要，可以理解为声明此方法的泛型方法。
##只有声明了的方法才是泛型方法，泛型类中使用的泛型的成员方法并不是泛型方法。
##表明该方法使用泛型类T，此时才可以在方法中使用泛型类型T。
##与泛型类的定义一样，此处T可以写任意标识，常见的如 T、 E、 K、 V 等形式的参数常用于表示泛型。

#类型通配符：

<?>无限制通配符：表示我们可以传入任意类型的参数
##类型通配符一般是使用 “?” 代替具体的类型实参
##类型通配符是类型实参，而不是类型形参

类型通配符的上限：
语法
类/接口 <? extends 实参类型>
要求该泛型的类型只能是实参类型，或实参类型的子类类型

类型通配符的下限：

语法
类/接口<? super 实参类型>
要求该泛型的类型只能是实参类型，或实参类型的父类类型

类型擦除：
概念：泛型是Java 1.5版本才引进的概念，在这之前是没有泛型的，但是，泛型代码能够很好地和之前版本的代码兼容。这是因为，泛型信息只存在于代码的编译阶段，在进入JVM之前，与泛型相关的信息会被擦除掉，我们称之为–类型擦除。

无限制类型擦除
有限制类型擦除：
擦除方法中类型定义的参数
类型擦除-桥接：

泛型与数组：

可以声明带泛型的数组引用，但是不能直接创建带泛型的数组对象。
可以通过 java.lang.reflect.Array 的 newInstance(Class,int)创建 T[]数组。

泛型命名

泛型一些约定俗成的命名：当然换个A-Z中另一个字母表示没有关系，但是为了可读性，一般有以下定义：

E - Element
K - Key
N - Number
T - Type
V - Value
S,U,V etc. - 2nd, 3rd, 4th types

使用泛型的建议
消除类型检查告警
List 优先于数组
优先考虑使用泛型来提高代码通用性
优先考虑泛型方法来限定泛型的范围
利用有限制通配符来提升 API 的灵活性
优先考虑类型安全的异构容器

##泛型的限制与局限:
不能用基本类型实例化类型化参数
运行时类型查询只适用于原始类型
不能创建参数化类型的数组
不能实例化类型变量
可以消除对受查异常的检查
@SuppressWamings("unchecked") 
public static <T extends Throwable〉void throwAs(Throwable e) throws T { throw (T) e; }

##总结：
  
  泛型方法能使方法独立于类而产生变化
  如果static方法要使用泛型能力，就必须使其成为泛型方法