## 前言

这是我的第二篇专门介绍如何去学习某个知识点的文章, 在上一篇[《写给 Java 程序员看的算法学习指南！》](https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247486508&idx=1&sn=ce2faafcde166d5412d7166a01fdc1e9&chksm=cea243e7f9d5caf1dbf4d6ccf0438a1731bc0070310bba1ac481d485e4a6756349c20f02a6b1&token=211950660&lang=zh_CN#rd) 的文章中, 我推荐了一些关于 **算法学习的书籍以及资源** . 

相比于写技术文章来说, 写这种这种类型的文章实际花费的时间可能会稍微少一点. 但是, 这种学习指南形式的文章, 我想对于 Java 初学者甚至是工作几年的 Java 工程师来说应该还是非常有帮助的！

我们都知道多线程应该是大部分 Java 程序员最难啃的一块骨头之一, 这部分内容的难度跨度大, 难实践, 并且市面上的参考资料的质量也层次不齐. 

在这篇文章中, 我会首先介绍一下 **Java 多线程学习** 中比较重要的一些问题, 然后还会推荐一些比较不错的学习资源供大家参考. 希望对你们学习多线程相关的知识能有帮助. 以下介绍的很多知识点你都可以在这里找到：[https://snailclimb.gitee.io/javaguide/#/?id=并发](https://snailclimb.gitee.io/javaguide/#/?id=并发)

![](images/多线程学习指南/javaguide-并发.png)

**另外, 我还将本文的内容同步到了 Github 上, 点击阅读原文即可直达. 如果你觉得有任何需要完善和修改的地方, 都可以去 Github 给我提交 Issue 或者 PR（推荐）. **

## 一.Java 多线程知识点总结

### 1.1.多线程基础

1. 什么是线程和进程? 线程与进程的关系,区别及优缺点? 
2. 说说并发与并行的区别?
3. 为什么要使用多线程呢?
4. 使用多线程可能带来什么问题?（内存泄漏、死锁、线程不安全等等）
5. 创建线程有哪几种方式? （a.继承 Thread 类;b.实现 Runnable 接口;c. 使用 Executor 框架;d.使用 FutureTask）
6. 说说线程的生命周期和状态?
7. 什么是上下文切换?
8. 什么是线程死锁?如何避免死锁?
9. 说说 sleep() 方法和 wait() 方法区别和共同点?
10. 为什么我们调用 start() 方法时会执行 run() 方法, 为什么我们不能直接调用 run() 方法? 
11. ......

### 1.2.多线程知识进阶

#### volatile 关键字

1. Java 内存模型（**JMM**）;
2. 重排序与 happens-before 原则了解吗?
3. volatile 关键字的作用;
4. 说说 synchronized 关键字和 volatile 关键字的区别;
5. ......

#### ThreadLocal

1. 有啥用（解决了什么问题）? 怎么用? 
2. 原理了解吗? 
3. 内存泄露问题了解吗? 

#### 线程池

1. 为什么要用线程池? 
2. 你会使用线程池吗? 
3. 如何创建线程池比较好?  （推荐使用 `ThreadPoolExecutor` 构造函数创建线程池）
4. `ThreadPoolExecutor` 类的重要参数了解吗? `ThreadPoolExecutor` 饱和策略了解吗? 
5. 线程池原理了解吗? 
6. 几种常见的线程池了解吗? 为什么不推荐使用`FixedThreadPool`? 
7. 如何设置线程池的大小? 
8. ......

#### AQS

1. 简介
2. 原理
3. AQS 常用组件. 
   - **Semaphore(信号量)**-允许多个线程同时访问
   - **CountDownLatch （倒计时器）**-CountDownLatch 允许 count 个线程阻塞在一个地方, 直至所有线程的任务都执行完毕. 
   - **CyclicBarrier(循环栅栏)**-CyclicBarrier 和 CountDownLatch 非常类似, 它也可以实现线程间的技术等待, 但是它的功能比 CountDownLatch 更加复杂和强大. 主要应用场景和 CountDownLatch 类似. 
   - **ReentrantLock 和 ReentrantReadWriteLock**
   - ......

#### 锁

锁的常见分类

1. 可重入锁和非可重入锁

* ReentrantLock和synchronized都是可重入锁
* 可重入锁表示能够对共享资源能够重复加锁, 即当前线程获取该锁再次获取不会被阻塞, 广义上的可重入锁指的是可重复可递归调用的锁
* 不可重入锁与可重入锁相反, 不可递归调用, 递归调用就发生死锁. 

2. 公平锁与非公平锁

* 如果一个锁是公平的, 那么锁的获取顺序就应该符合请求上的绝对时间顺序, 满足FIFO, ReentrantLock的构造方法无参时是构造非公平锁. 
* 公平锁每次获取到锁为同步队列中的第一个节点, 保证请求资源时间上的绝对顺序, 而非公平锁有可能刚释放锁的线程下次继续获取该锁, 则有可能导致其他线程永远无法获取到锁, 造成“饥饿”现象. 
* 公平锁为了保证时间上的绝对顺序, 需要频繁的上下文切换, 而非公平锁会降低一定的上下文切换, 降低性能开销. 因此, ReentrantLock默认选择的是非公平锁, 则是为了减少一部分上下文切换, 保证了系统更大的吞吐量. 
* 公平锁每次都是从同步队列中的第一个节点获取到锁, 而非公平性锁则不一定, 有可能刚释放锁的线程能再次获取到锁.

3. 读写锁和排它锁

* 读写锁既是互斥锁, 又是共享锁, read模式是共享, write是互斥(排它锁)的.

4. 独享锁和共享锁

* 独享锁每一次只能被一个线程所持有
* 共享锁可被多个线程共有， 典型的就是ReentrantReadWriteLock里的读锁， 它的读锁是可以被共享的， 但是它的写锁确每次只能被独占

5. 乐观锁和悲观锁

*乐观锁总是假设最坏的情况, 每次去拿数据的时候都认为别人会修改, 所以每次在拿数据的时候都会上锁, 这样别人想拿这个数据就会阻塞直到它拿到锁(共享资源每次只给一个线程使用, 其它线程阻塞, 用完后再把资源转让给其它线程)
*悲观锁总是假设最好的情况, 每次去拿数据的时候都认为别人不会修改, 所以不会上锁, 但是在更新的时候会判断一下在此期间别人有没有去更新这个数据, 可以使用版本号机制和CAS算法实现, 乐观锁适用于多读的应用类型, 这样可以提高吞吐量

6. 偏向锁、轻量级锁和重量级锁

* 锁的状态： 无锁状态、 偏向锁状态、轻量级锁状态、重量级锁状态, 锁的状态是通过对象监视器在对象头中的字段来表明的, 四种状态会随着竞争的情况逐渐升级, 而且是不可逆的过程, 即不可降级, 这四种状态都不是Java语言中的锁, 而是Jvm为了提高锁的获取与释放效率而做的优化(使用synchronized时).
* 偏向锁: 偏向锁是指一段同步代码一直被一个线程所访问, 那么该线程会自动获取锁, 降低获取锁的代价
* 轻量级: 轻量级锁是指当锁是偏向锁的时候,被另一个线程所访问, 偏向锁就会升级为轻量级锁, 其他线程会通过自旋的形式尝试获取锁, 不会阻塞, 提高性能
* 重量级锁: 重量级锁是指当锁为轻量级锁的时候, 另一个线程虽然是自旋, 但自旋不会一直持续下去, 当自旋一定次数的时候, 还没有获取到锁, 就会进入阻塞, 该锁膨胀为重量级锁, 重量级锁会让其他申请的线程进入阻塞, 性能降低. 
* 自旋锁: 是指当一个线程在获取锁的时候, 如果锁已经被其它线程获取, 那么该线程将循环等待, 然后不断的判断锁是否能够被成功获取, 直到获取到锁才会退出循环.  

7. 自旋锁优缺点

* 自旋锁的优点
> 自旋锁不会使线程状态发生切换，一直处于用户态，即线程一直都是active的；不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快 
> 非自旋锁在获取不到锁的时候会进入阻塞状态，从而进入内核态，当获取到锁的时候需要从内核态恢复，需要线程上下文切换。 （线程被阻塞后便进入内核（Linux）调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能
* 自旋锁的缺点
> 如果某个线程持有锁的时间过长，就会导致其它等待获取锁的线程进入循环等待，消耗CPU。使用不当会造成CPU使用率极高。
> 上面Java实现的自旋锁不是公平的，即无法满足等待时间最长的线程优先获取锁。不公平的锁就会存在“线程饥饿”问题。
    
    
8. 自旋锁与互斥锁
    
* 自旋锁与互斥锁都是为了实现保护资源共享的机制.
* 无论是自旋锁还是互斥锁，在任意时刻，都最多只能有一个保持者.
* 互斥锁的线程, 如果锁已经被占用, 则该线程将进入睡眠状态, 获取自旋锁的线程则不会睡眠, 而是一直循环等待锁释放.
   

**synchronized 关键字**

1. 说一说自己对于 synchronized 关键字的了解; 
2. 说说自己是怎么使用 synchronized 关键字, 在项目中用到了吗;
3. 讲一下 synchronized 关键字的底层原理; 
4. 说说 JDK1.6 之后的 synchronized 关键字底层做了哪些优化, 可以详细介绍一下这些优化吗; 
5. 谈谈 synchronized 和 ReentrantLock 的区别; 
6. ......

**ReentrantLock 和 ReentrantReadWriteLock**

**ReadWriteLock**

**StampedLock（JDK8）**

#### ReentrantLock vs synchronized

#### **Atomic 与 CAS**

**CAS:**

1. 介绍
2. 原理

**Atomic 原子类：**

1.  介绍一下 Atomic 原子类; 
2.  JUC 包中的原子类是哪 4 类?; 
3.  讲讲 AtomicInteger 的使用; 
4.  能不能给我简单介绍一下 AtomicInteger 类的原理. 
5.  ......

#### 并发容器

JDK 提供的这些容器大部分在 `java.util.concurrent` 包中. 

- **ConcurrentHashMap:** 线程安全的 HashMap
- **CopyOnWriteArrayList:** 线程安全的 List, 在读多写少的场合性能非常好, 远远好于 Vector.
- **ConcurrentLinkedQueue:** 高效的并发队列, 使用链表实现. 可以看做一个线程安全的 LinkedList, 这是一个非阻塞队列. 
- **BlockingQueue:** 这是一个接口, JDK 内部通过链表、数组等方式实现了这个接口. 表示阻塞队列, 非常适合用于作为数据共享的通道. 
- **ConcurrentSkipListMap:** 跳表的实现. 这是一个 Map, 使用跳表的数据结构进行快速查找. 
- ......

#### Future 和 CompletableFuture

## 二.书籍推荐

#### 《Java 并发编程之美》

![《Java 并发编程之美》](images/多线程学习指南/java并发编程之美.png)

**我觉得这本书还是非常适合我们用来学习 Java 多线程的. 这本书的讲解非常通俗易懂, 作者从并发编程基础到实战都是信手拈来. **

另外, 这本书的作者加多自身也会经常在网上发布各种技术文章. 我觉得这本书也是加多大佬这么多年在多线程领域的沉淀所得的结果吧！他书中的内容基本都是结合代码讲解, 非常有说服力！

#### 《实战 Java 高并发程序设计》

![《实战 Java 高并发程序设计》](images/多线程学习指南/实战Java高并发程序设计.png)

这个是我第二本要推荐的书籍, 比较适合作为多线程入门/进阶书籍来看. 这本书内容同样是理论结合实战, 对于每个知识点的讲解也比较通俗易懂, 整体结构也比较清. 

#### 《深入浅出 Java 多线程》

![《深入浅出Java多线程》](images/多线程学习指南/深入浅出Java多线程.png)

这本书是几位大厂（如阿里）的大佬开源的, Github 地址：[https://github.com/RedSpider1/concurrent](https://github.com/RedSpider1/concurrent)

几位作者为了写好《深入浅出 Java 多线程》这本书阅读了大量的 Java 多线程方面的书籍和博客, 然后再加上他们的经验总结、Demo 实例、源码解析, 最终才形成了这本书. 

这本书的质量也是非常过硬！给作者们点个赞！这本书有统一的排版规则和语言风格、清晰的表达方式和逻辑. 并且每篇文章初稿写完后, 作者们就会互相审校, 合并到主分支时所有成员会再次审校, 最后再通篇修订了三遍. 

#### 《Java 并发编程的艺术》

![《Java 并发编程的艺术》](images/多线程学习指南/Java并发编程的艺术.png)

这本书不是很适合作为 Java 多线程入门书籍, 需要具备一定的 JVM 基础, 有些东西讲的还是挺深入的. 另外, 就我自己阅读这本书的感觉来说, 我觉得这本书的章节规划有点杂乱, 但是, 具体到某个知识点又很棒！这可能也和这本书由三名作者共同编写完成有关系吧！

**综上：这本书并不是和 Java 多线程入门, 你也不需要把这本书的每一章节都看一遍, 建议挑选自己想要详细了解的知识点来看. **

## 三.总结

在这篇文章中我主要总结了 Java 多线程方面的知识点, 并且推荐了相关的书籍. 并发这部分东西实战的话比较难, 你可以尝试学会了某个知识点之后然后在自己写过的一些项目上实践. 另外, leetcode 有一个练习多线程的类别： [https://leetcode-cn.com/problemset/concurrency](https://leetcode-cn.com/problemset/concurrency) 可以作为参考. 

**为了这篇文章的内容更加完善, 我还将本文的内容同步到了 Github 上, 点击阅读原文即可直达. 如果你觉得有任何需要完善和修改的地方, 都可以去 Github 给我提交 Issue 或者 PR（推荐）. **